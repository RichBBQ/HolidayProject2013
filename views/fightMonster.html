<!DOCTYPE html>
<html>
<head>
    <title>Monster Fight!</title>
    <link rel="stylesheet" type="text/css" href="../css/fightMonsterLayout.css" />
    <link rel="stylesheet" type="text/css" href="../css/fightMonster.css" />
    <link rel="stylesheet" type="text/css" href="../css/attackTools.css" />
    <script src="http://code.jquery.com/jquery-2.0.3.min.js"></script>
    <script src="../js/ArrowPositionCalculator.js"></script>
    <script src="../js/MessageGenerater.js"></script>
    <script src="../js/Utilities.js"></script>
    <script type="text/javascript">
        var playerData = JSON.parse('{{{json playerData}}}');
        var monsterData = JSON.parse('{{{json monsterData}}}');
        var refreshPeriod = 30; // refresh every 30ms
        var shortestWaitLength = 5000; // 5 sec
        var waitThreshold = 220;
        // For the person with the most agility, this delta per refresh will make sure the
        // person turn takes a turn every "shortestWaitingLength"
        var baseWaitBarDeltaPerRefresh = ((refreshPeriod * waitThreshold) / shortestWaitLength);
        var maxAgility = 100; // biggest agility of everyone involved in this match. Used for turnThreshold calc.
        var profileCache = {}; // Cache DOM Object to reduce search time
        var pauseWaitProgress = false;

        // Attack tool related objects
        var battleView = undefined;
        var battleMessage = undefined;
        var actorInAction = undefined;
        var arrow = undefined;
        var arrowPositionCalculator = undefined;
        var turnQueue = [];
        var atkActionInProgress = false;
        var updateArrow = false;
        var messageGenerater = undefined;

        // Monster AI related
        var monsterTurnScheduled = false;

        // Victory condition
        var playersWon = false;
        var monsterWon = false;

        function initMaxAgility() {
            var updateMaxAgility = function(actorData) {
                if (actorData.hasOwnProperty('aggrAgi') && actorData['aggrAgi'] > maxAgility) {
                    maxAgility = actorData['aggrAgi'];
                }
            }

            // Need to figure out the max agility across player/monster
            for (var actor in playerData) {
                if (playerData.hasOwnProperty(actor)) {
                    updateMaxAgility(playerData[actor]);
                }
            }
            for (var actor in monsterData) {
                if (monsterData.hasOwnProperty(actor)) {
                    updateMaxAgility(monsterData[actor]);
                }
            }
        }

        function initWaitProgress() {
            var startingProgress = 0; // TODO: reset back to zero, set high for testing purpose
            for (var actor in playerData) {
                var a = playerData[actor];
                a['waitProgress'] = startingProgress;
            }
            for (var actor in monsterData) {
                var a = monsterData[actor];
                a['waitProgress'] = startingProgress;
            }
        }

        /**
         * Cache DOM Object to reduce dom manipulation time.
         * This application will quite heavily update profiles.
         */
        function initProfileCache() {
            for (var actor in playerData) {
                profileCache[actor] = $('#'+actor);
            }
            for (var actor in monsterData) {
                profileCache[actor] = $('#'+actor);
            }
        }

        function initBattleView() {
            battleView = $('#lightbox');
            battleMessage = $('#battleMessage');
            actorInAction = $('#actorInAction');
            arrow = $('#arrow');
            arrowPositionCalculator = new ArrowPositionCalculator();
        }

        function initMisc() {
            messageGenerater = new MessageGenerater();
        }

        function registerActionKeys() {
            $(document).keydown(function(e){
                 if (e.keyCode === 32) { // white space
                     userAttackActionHandler();
                 }
            });
        }

        function searchActor(actorName) {
            if (playerData.hasOwnProperty(actorName)) {
                return playerData[actorName];
            }
            else if (monsterData.hasOwnProperty(actorName)) {
                return monsterData[actorName];
            }
            else {
                return {};
            }
        }

        function updateWaitBars() {
            if (pauseWaitProgress) {
                return;
            }
            for (var actor in profileCache) {
                var actorData = searchActor(actor);
                // don't update dead people
                if (actorData['isDead'] !== undefined && actorData['isDead']) {
                    continue;
                }

                var profile = profileCache[actor];
                var actorAgi = actorData['agi'];
                var currentWaitProgress = actorData['waitProgress'];
                // reset mercury is it's full
                if (currentWaitProgress >= waitThreshold) {
                    currentWaitProgress = 0;
                }

                // Get the delta for this player this turn.
                // The player with "maxAgility" should receive
                // the same delta as "baseWaitBarDeltaPerRefresh"
                var deltaForActor = (actorAgi * baseWaitBarDeltaPerRefresh) / maxAgility;

                // Update the wait bar, but don't go over waitThreshold
                var waitProgress = currentWaitProgress + deltaForActor;

                if (waitProgress > waitThreshold) {
                    waitProgress = waitThreshold;
                    // this actor can take a turn now, register it in turnQueue
                    // to be picked up by another observer thread.
                    turnQueue.push(actor);
                }
                actorData['waitProgress'] = waitProgress;
                profile.find('.mercury').width(waitProgress);
            }
        }

        function actorTurnObserver() {
            if (turnQueue.length <= 0 || atkActionInProgress) {
                // No one can act yet
                return;
            }
            pauseWaitProgress = true;
            var actorToTakeTurn = turnQueue.shift();
            var actorData = searchActor(actorToTakeTurn);

            // Put actorData into actorInAction dom cache
            refreshProfile(actorInAction, actorData);
            profileCache[actorToTakeTurn].addClass('profileSelected');
            profileCache[actorToTakeTurn].addClass('selectedProfileColoring');
            profileCache[actorToTakeTurn].removeClass('playerProfileColoring');
            profileCache[actorToTakeTurn].removeClass('monsterProfileColoring');

            arrowPositionCalculator.reset();
            updateArrow = true;
            atkActionInProgress = true;
            battleView.show();
        }

        function refreshProfile(profileDom, actorData) {
            profileDom.find('.actorName').html(actorData['playerName']);
            profileDom.find('.level').html(actorData['level']);
            profileDom.find('.pow').html(actorData['aggrPow']);
            profileDom.find('.hp').html(actorData['aggrHp']);
            profileDom.find('.agi').html(actorData['aggrAgi']);
            profileDom.find('.profilePic').attr('src', actorData['playerPicLink']);

        }

        function attackAction() {
            // Only do work when atkActionInProgress and updating arrow
            if (!atkActionInProgress || !updateArrow) {
                return;
            }
            arrowPositionCalculator.updatePosition();
            var newPos = arrowPositionCalculator.getPosition() + "%";
            arrow.css('left', newPos);
        }

        function atLeastOnePlayerAlive() {
            for (var player in playerData) {
                var isDead = playerData[player]['isDead'];
                if (isDead === undefined || !isDead) {
                    return true;
                }
            }
            return false;
        }

        function atLeastOneMonsterAlive() {
            for (var m in monsterData) {
                var isDead = monsterData[m]['isDead'];
                if (isDead === undefined || !isDead) {
                    return true;
                }
            }
            return false;
        }

        function monsterAI() {
            if (!atkActionInProgress || !updateArrow || !currentActorIsAMonster() || monsterTurnScheduled) {
                return;
            }
            // double check if it's the monster's turn
            if (atkActionInProgress && updateArrow && currentActorIsAMonster() && (!monsterTurnScheduled)) {
                // First check if there's any player alive or not
                if (!atLeastOnePlayerAlive()) {
                    monsterTurnScheduled = false;
                    monsterWon = true;
                    return;
                }

                var monsterActionLength = getRandomInt(2000, 6500);
                setTimeout(function(){
                    updateArrow = false;
                    var actorData = getCurrentActorData();
                    var target = getRandomEntryFromJson(playerData);
                    // select a non dead target
                    while (target['isDead']) {
                        target = getRandomEntryFromJson(playerData);
                    }
                    var dmg = getCurrentActorDamageOutput();
                    var targetProfileDom = profileCache[target['playerName']];

                    // Apply damage and have a quick showing
                    target['aggrHp'] = target['aggrHp'] - dmg;
                    if (target['aggrHp'] < 0) {
                        markActorDead(target['playerName']);
                        target['isDead'] = true;
                        target['aggrHp'] = 0;
                    }
                    var atkMsg = messageGenerater.generateAttackMessage(actorData, target, dmg);

                    // Blink attacked people for visual effect
                    var blinkTimes = 3;
                    var blinked = 0;
                    var blinkLength = 200;
                    var blinkAnimeInterval = setInterval(function() {
                        targetProfileDom.fadeOut(blinkLength / 2);
                        targetProfileDom.fadeIn(blinkLength / 2);
                        blinked += 1;
                        if (blinked >= blinkTimes) {
                            clearInterval(blinkAnimeInterval);
                        }
                    }, blinkLength);
                    refreshProfile(targetProfileDom, target);
                    battleMessage.html(atkMsg);
                    battleMessage.show();

                    setTimeout(function(){
                        // Set everything back to action ONLY AFTER the atk message is done displaying.
                        atkActionInProgress = false;
                        battleMessage.hide();
                        battleView.hide();
                        pauseWaitProgress = false;
                        monsterTurnScheduled = false;
                        unSelectActor(actorData['playerName']);
                    }, 3000);

                }, monsterActionLength);
                monsterTurnScheduled = true;
            }
        }

        function userAttackActionHandler() {
            // Only do work when atkActionInProgress and updating arrow
            if (!atkActionInProgress || !updateArrow || currentActorIsAMonster()) {
                return;
            }
            updateArrow = false;
            var actorData = getCurrentActorData();
            // by reference. target points to the actual json object in monsterData.
            // updating "target" object will have direct effect on what's stored in monsterData.
            var target = getRandomEntryFromJson(monsterData);
            var dmg = getCurrentActorDamageOutput();
            var targetProfileDom = profileCache[target['playerName']];

            // Apply damage and have a quick showing
            target['aggrHp'] = target['aggrHp'] - dmg;
            if (target['aggrHp'] <= 0) { // target dead
                markActorDead(target['playerName']);
                target['isDead'] = true;
                target['aggrHp'] = 0;
                if (!atLeastOneMonsterAlive()) {
                     playersWon = true;
                }
            }
            var atkMsg = messageGenerater.generateAttackMessage(actorData, target, dmg);

            // Blink attacked people for visual effect
            var blinkTimes = 3;
            var blinked = 0;
            var blinkLength = 200;
            var blinkAnimeInterval = setInterval(function() {
                targetProfileDom.fadeOut(blinkLength / 2);
                targetProfileDom.fadeIn(blinkLength / 2);
                blinked += 1;
                if (blinked >= blinkTimes) {
                    clearInterval(blinkAnimeInterval);
                }
            }, blinkLength);
            battleMessage.html(atkMsg);
            battleMessage.show();
            refreshProfile(targetProfileDom, target);
            // TODO: insert attack sound effect here

            // Allow message up for 3 seconds
            setTimeout(function(){
                // Set everything back to action ONLY AFTER the atk message is done displaying.
                atkActionInProgress = false;
                battleMessage.hide();
                battleView.hide();
                pauseWaitProgress = false;
                unSelectActor(actorData['playerName']);
            }, 3000);
        }

        function unSelectActor(actorName) {
            var actorData = searchActor(actorName);
            profileCache[actorName].removeClass('profileSelected');
            profileCache[actorName].removeClass('selectedProfileColoring');
            if (actorData['actorType'] == 'm') {
                profileCache[actorName].addClass('monsterProfileColoring');
            }
            else {
                profileCache[actorName].addClass('playerProfileColoring');
            }
        }

        function markActorDead(actorName) {
            var actorData = searchActor(actorName);
            profileCache[actorName].removeClass('selectedProfileColoring');
            profileCache[actorName].removeClass('playerProfileColoring');
            profileCache[actorName].removeClass('monsterProfileColoring');
            profileCache[actorName].addClass('actorDead');
        }

        function currentActorIsAMonster() {
            var actorData = getCurrentActorData();
            if (actorData === undefined) {
                return false;
            }
            return (actorData['actorType'] == 'm');
        }

        /**
         * Helper function to get dmg output. Assumption is made that actorInAction is filled in
         * and atkActionInProgress is already set to false so the arrow has stopped moving.
         */
        function getCurrentActorDamageOutput() {
            var actorData = getCurrentActorData();
            var arrowPos = arrowPositionCalculator.getAdjustedPosition();
            var damageOutput = actorData['aggrPow'] - Math.floor((actorData['aggrPow'] * Math.abs(arrowPos - 50)) / 50) ;
            return damageOutput;
        }

        function getCurrentActorData() {
            var actorName = actorInAction.find('.actorName').html();
            var actorData = searchActor(actorName);
            return actorData;
        }

        function getRandomEntryFromJson(jsonObj) {
            var jsonObjArr = $.map(jsonObj, function(value, key){ return value; });
            jsonObjArr = shuffle(jsonObjArr);
            return jsonObjArr.shift();
        }

        $(document).ready(function($){
            initMaxAgility();
            initWaitProgress();
            initProfileCache();
            initBattleView();
            initMisc();
            registerActionKeys();

            /*
            var testRun = 0;
            var interval = setInterval(function() {
                updateWaitBars();
                testRun += 1;
                if (testRun >= 10) {
                    clearInterval(interval);
                }
            }, refreshPeriod);
            */
            setInterval(updateWaitBars, refreshPeriod);
            setInterval(actorTurnObserver, refreshPeriod);
            setInterval(attackAction, refreshPeriod);
            setInterval(monsterAI, 2000); // monster AI can run less often
        });
    </script>
</head>
<body>
    <div class="playerProfilesContainer">
        <div class="playerListContainer">
        {{#each playerData}}
            <div class="player playerProfileColoring" id="{{this.playerName}}">
                <div class="attributes">
                    <div class="name"><span class="actorName">{{this.playerName}}</span></div>
                    <div class="attributeContainer">
                        <div class="attr">Level: </div><div class="attrVal level">{{this.level}}</div>
                    </div>
                    <div class="attributeContainer">
                        <div class="attr">Power: </div><div class="attrVal pow">{{this.aggrPow}}</div>
                    </div>
                    <div class="attributeContainer">
                        <span class="attr">HP: </span><span class="attrVal hp">{{this.aggrHp}}</span>
                    </div>
                    <div class="attributeContainer">
                        <span class="attr">Agility: </span><span class="attrVal agi">{{this.aggrAgi}}</span>
                    </div>
                </div>
                <div class="imageContainer">
                    <img class="profilePic" src="{{this.playerPicLink}}" />
                </div>
                <div class="thermometer">
                    <span class="mercury"></span>
                </div>
            </div>
        {{/each}}
        </div>
    </div>

    <div id="lightbox">
        <div id="meterTool">
            <div class="meterenclosing">
                <img class="meter" src="../resource/meter_base.jpg" />
            </div>
            <div class="arrowenclosing">
                <img id="arrow" class="arrow" src="../resource/up_arrow.png" />
            </div>
        </div>

        <div id="battleMessage" class="battleMessage"></div>
    </div>

    <div class="monsterProfilesContainer">
    {{#each monsterData}}
        <div class="monster monsterProfileColoring" id="{{this.playerName}}">
            <div class="attributes">
                <div class="name"><span class="actorName">{{this.playerName}}</span></div>
                <div class="attributeContainer">
                    <div class="attr">Level: </div><div class="attrVal level">{{this.level}}</div>
                </div>
                <div class="attributeContainer">
                    <div class="attr">Power: </div><div class="attrVal pow">{{this.aggrPow}}</div>
                </div>
                <div class="attributeContainer">
                    <span class="attr">HP: </span><span class="attrVal hp">{{this.aggrHp}}</span>
                </div>
                <div class="attributeContainer">
                    <span class="attr">Agility: </span><span class="attrVal agi">{{this.aggrAgi}}</span>
                </div>
            </div>
            <div class="imageContainer">
                <img class="profilePic" src="{{this.playerPicLink}}" />
            </div>
            <div class="thermometer">
                <span class="mercury"></span>
            </div>
        </div>
    {{/each}}
    </div>


    <!-- Place Holder for cache purpose -->
    <div class="actorInActionContainer">
        <div id="actorInAction">
            <span class="actorName"></span>
            <div class="level"></div>
            <div class="pow"></div>
            <div class="hp"></div>
            <div class="agi"></div>
            <img class="profilePic" src="" />
        </div>
    </div>
</body>
</html>